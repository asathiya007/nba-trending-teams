<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    <title>Public Opinion of NBA Teams Based on Tweets</title>
    <!-- import required libraries here -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script src= "https://d3js.org/d3-color.v1.min.js"></script> 
    <script src= "https://d3js.org/d3-interpolate.v1.min.js"></script> 
    <script src= "https://d3js.org/d3-scale-chromatic.v1.min.js"></script> 
    <style>
        /* define CSS rules here */
        /* h1{text-align: center;} */
    </style>

    <!-- trying to remove some annoying error in chrome console-->
    <link rel="shortcut icon" href="#">

    <title></title>
</head>


<body>
    <!-- Add heading for the visualization -->
    <h1>Public Opinion of NBA Teams Based on Tweets</h1>
    <!-- Create dropdown element here. Options should be added after reading in game file, they should not be created here.-->
    

    <!-- append visualization svg to this div-->
    <div id="line_graph"><svg></svg></div>
    <!-- <div id="tooltip"><text id="tip"></text></div> -->

    <script>

        // enter code to define margin and dimensions for svg
        var margin = 100;
        var width = 1100;
        var height = 1300;

        // enter code to create svg
        var svg = d3.select("svg")
                  .attr('id', 'svg')
                  .attr('width', width)
                  .attr('height', height);

        var selection_menu = svg.append("g")
                  .attr('id', 'menu')
                  .attr('width', width - 160)
                  .attr('height', height - 50);

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 25)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Model Select')

        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 28)")
                  .attr("width", 175)
                  .attr("height", 50)
                  .append("xhtml:body")
                  .html("<form><select id='modelDropdown'>\
                                <option value='rf'> Random Forest </option>\
                                <option value='nb'> Naive Bayes </option>\
                                <option value='lr'> Logistic Regression </option>\
                                /></form>")

        selection_menu.append("text")
                  .attr("id", "team_select_text")
                  .attr("transform", "translate(0, 75)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Team Select')
        
        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 80)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select multiple id='teamDropdown'> /></form>")

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 180)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Min Date Select')
        
        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 185)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select id='minDateDropdown'> /></form>")

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 240)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Max Date Select')

        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 245)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select id='maxDateDropdown'> /></form>")

        // enter code to define tooltip
        var tip = d3.tip().attr("id", "tooltip").attr('class', 'd3-tip')
                    .html(function(d) {return "Team: " + d[2].charAt(0).toUpperCase() + d[2].slice(1);});
                                            //    "<br>Game: " + currGame + 
                                            //    "<br>Avg Rating: " + getData(d.properties.name, currGame, global_count_data)[0] + 
                                            //    "<br>Number of Users: " + getData(d.properties.name, currGame, global_count_data)[1];});

        // enter code to define projection and path required for Choropleth
        // For grading, set the name of functions for projection and path as "projection" and "path"

        var projection = d3.geoNaturalEarth().translate([400, 300]).scale(150);
        var path = d3.geoPath().projection(projection);


        // define any other global variables 
        var pathToCountCSV = "tweet_counts.csv";
        var pathToTweetsCSV = "rf_positive_tweets.csv"
        var gameColumn = []
        var currGame = ""
        var currCountry = ""
        var global_count_data = null
        var currModel = ["rf"]
        var currTeams = ['76ers', 'blazers', 'bucks', 'bulls', 'cavaliers', 'celtics', 'grizzlies', 'hawks', 'heat', 'hornets', 'jazz', 'kings', 'knicks', 'lakers', 'magic', 'mavericks', 'nets', 'nuggets', 'pacers', 'pelicans', 'pistons', 'raptors', 'rockets', 'spurs', 'suns', 'thunder', 'timberwolves', 'wizards']
        var minDate = "2021-11-09"
        var maxDate = null
        var absoluteMax = null
        var min_tweet_count = 0
        var max_tweet_count = 0
        var min_tweet_count_negative = 0
        var max_tweet_count_negative = 0
        Promise.all([
            // enter code to read files
            d3.csv(pathToCountCSV),
            d3.csv(pathToTweetsCSV)
            
        ]).then(
            // enter code to call ready() with required arguments
            results => {
                count_data = results[0];
                console.log(count_data);
                tweets = results[1];
                ready(null, tweets, count_data);
            }
        );

        function processData(count_data, positive) {
            lines = []
            for (let [key, value] of Object.entries(count_data)) {
                currLine = []
                for (let i = 0; i < value[0].length; i++) {
                    if (positive) {
                        currLine.push([value[0][i], parseInt(value[1][i]), key])
                    } else {
                        currLine.push([value[0][i], parseInt(value[2][i]), key])
                    }
                    
                }
                lines.push(currLine)
            }
            return lines;
        }
        
        // this function should be called once the data from files have been read
        // world: topojson from world_countries.json
        // count_data: data from ratings-by-country.csv
        
        function ready(error, tweets, count_data) {
            global_count_data = count_data
            // enter code to extract all unique games from count_data 
            // and append the game options to the dropdown

            d3.select("#teamDropdown").selectAll("option")
              .data(['76ers', 'Blazers', 'Bucks', 'Bulls', 'Cavaliers', 'Celtics', 'Grizzlies', 'Hawks', 'Heat', 'Hornets', 'Jazz', 'Kings', 'Knicks', 'Lakers', 'Magic', 'Mavericks', 'Nets', 'Nuggets', 'Pacers', 'Pelicans', 'Pistons', 'Raptors', 'Rockets', 'Spurs', 'Suns', 'Thunder', 'Timberwolves', 'Wizards'])
              .enter()
              .append("option")
              .text(function(d){return d;})

            var checkboxes = document.querySelectorAll("input[type=checkbox][name=teamselect]");
            var selectedTeams = []
            checkboxes.forEach(function(checkbox) {
                checkbox.addEventListener('change', function() {
                    selectedTeams = 
                    Array.from(checkboxes) // Convert checkboxes to an array to use filter and map.
                    .filter(i => i.checked) // Use Array.filter to remove unchecked checkboxes.
                    .map(i => i.value) // Use Array.map to extract only the checkbox values from the array of objects.
                })
            });
            
            var dateParser = d3.timeParse("%Y-%m-%d")
            console.log(count_data)
            stringDates = [... new Set(count_data.map(function(value,index) { return value['Date']; }))]
            console.log(stringDates)
            var convertedDates = stringDates.map(function(x, index) {return dateParser(x).getTime()})
            minDate = stringDates[convertedDates.indexOf(Math.min(...convertedDates))]
            maxDate = stringDates[convertedDates.indexOf(Math.max(...convertedDates))]
            absoluteMax = stringDates[convertedDates.indexOf(Math.max(...convertedDates))]
            
            min_rftweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['RF Positive']})))
            max_rftweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['RF Positive']})))
            console.log(min_rftweet_count, max_rftweet_count)

            min_nbtweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['NB Positive']})))
            max_nbtweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['NB Positive']})))
            console.log(min_nbtweet_count, max_nbtweet_count)

            min_lrtweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['LR Positive']})))
            max_lrtweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['LR Positive']})))
            console.log(min_lrtweet_count, max_lrtweet_count)

            min_tweet_count = Math.min(min_rftweet_count, min_nbtweet_count, min_lrtweet_count)
            max_tweet_count = Math.max(max_rftweet_count, max_nbtweet_count, max_lrtweet_count)

            // for negative tweets
            min_rftweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['RF Negative']})))
            max_rftweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['RF Negative']})))
            console.log(min_rftweet_count, max_rftweet_count)

            min_nbtweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['NB Negative']})))
            max_nbtweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['NB Negative']})))
            console.log(min_nbtweet_count, max_nbtweet_count)

            min_lrtweet_count = Math.min(... new Set(count_data.map(function(value,index) { return value['LR Negative']})))
            max_lrtweet_count = Math.max(... new Set(count_data.map(function(value,index) { return value['LR Negative']})))
            console.log(min_lrtweet_count, max_lrtweet_count)

            min_tweet_count_negative = Math.min(min_rftweet_count, min_nbtweet_count, min_lrtweet_count)
            max_tweet_count_negative = Math.max(max_rftweet_count, max_nbtweet_count, max_lrtweet_count)



            // event listener for the dropdown. Update choropleth and legend when selection changes. Call createMapAndLegend() with required arguments.
            var select_Model = document.getElementById("modelDropdown")
            select_Model.addEventListener("change", function(){ var models = []; selected = d3.select(this).selectAll("option:checked").each(function() { models.push(this.value) }); currModel = models; createMapAndLegend(tweets, count_data, currModel, currTeams, minDate, maxDate); });

            var select_Teams = document.getElementById("teamDropdown")
            select_Teams.addEventListener("change", function(){ var teams = []; selected = d3.select(this).selectAll("option:checked").each(function() { teams.push(this.value.toLowerCase()) }); currTeams = teams; createMapAndLegend(tweets, count_data, currModel, currTeams, minDate, maxDate); });

            var select_Min_Date = document.getElementById("minDateDropdown")
            select_Min_Date.addEventListener("change", function(){ var values = []; selected = d3.select(this).selectAll("option:checked").each(function() { values.push(this.value) }); minDate = values[0]; createMapAndLegend(tweets, count_data, currModel, currTeams, minDate, maxDate); });

            var select_Max_Date = document.getElementById("maxDateDropdown")
            select_Max_Date.addEventListener("change", function(){ var values = []; selected = d3.select(this).selectAll("option:checked").each(function() { values.push(this.value) }); maxDate = values[0]; createMapAndLegend(tweets, count_data, currModel, currTeams, minDate, maxDate); });
            // create Choropleth with default option. Call createMapAndLegend() with required arguments. 
            createMapAndLegend(tweets, count_data, currModel, currTeams, minDate, maxDate);
        }

        // this function should create a Choropleth and legend using the world and count_data arguments for a selectedGame
        // also use this function to update Choropleth and legend when a different game is selected from the dropdown
        function createMapAndLegend(world, count_data, currModel, currTeams, minDate, maxDate){ 
            svg.selectAll("#error_date_range").remove()
            dates = [... new Set(count_data.map(function(value,index) { return value['Date']; }))]
            console.log(currModel)
            console.log(currTeams)
            console.log(minDate)
            console.log(maxDate)
            var dateParser = d3.timeParse("%Y-%m-%d")
            var minConvertedDate = dateParser(minDate).getTime()
            console.log(minConvertedDate)
            var maxConvertedDate = dateParser(maxDate).getTime()
            console.log(maxConvertedDate)
            if (minConvertedDate >= maxConvertedDate)
            {
                selection_menu.append("text")
                  .attr("id", "error_date_range")
                  .attr("transform", "translate(0, 530)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'red')
                  .text('Error: invalid date selection. Min date must be less than max date. Code has defaulted to the maximum possible date.')
                
                maxDate = absoluteMax
                maxConvertedDate = dateParser(maxDate).getTime()
                console.log(maxDate)
                // createMapAndLegend(world, count_data, currModel, currTeams, minDate, absoluteMax)
            }

            stringDates = [... new Set(count_data.map(function(value,index) { if (maxConvertedDate > dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            d3.select("#minDateDropdown").selectAll("option")
              .data(stringDates)
              .enter()
              .append("option")
              .text(function(d){return d;})

            stringDatesWithinBounds = [... new Set(count_data.map(function(value,index) { if (minConvertedDate < dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            d3.select("#maxDateDropdown").selectAll("option")
              .data(stringDatesWithinBounds)
              .enter()
              .append("option")
              .text(function(d){return d;})
              .property("selected", function(d) {return d === maxDate})

            var date_range = [... new Set(count_data.map(function(value,index) { if (minConvertedDate <= dateParser(value['Date']).getTime() && maxConvertedDate >= dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            console.log(date_range)
            var convertedDateRange = date_range.map(function(x, index) {return dateParser(x).getTime()})
            date_scale_min = convertedDateRange[convertedDateRange.indexOf(Math.min(...convertedDateRange))]
            date_scale_max = convertedDateRange[convertedDateRange.indexOf(Math.max(...convertedDateRange))]
            console.log(date_scale_min, date_scale_max)

            line_data = {}

            // for each team
            currTeams.forEach(element => {
                positiveCounts = []
                negativeCounts = []
                if (currModel == "rf") //random forest
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['RF Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['RF Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                    
                }
                else if (currModel == "nb") //naive bayes
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['NB Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['NB Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                }
                else //logistic regression
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['LR Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['LR Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                }
                line_data[element] = [convertedDateRange, positiveCounts, negativeCounts]
            });

            console.log(line_data)

            // create scales x & y for X and Y axis and set their ranges
            var xscale = d3.scaleLinear().domain([date_scale_min, date_scale_max]).range([0, width - 350])
            console.log(xscale.domain())
            var yscale = d3.scaleLinear().domain([min_tweet_count, max_tweet_count]).range([450, 0]).nice()

            const line = d3.line()
                    .x(function(d) { return xscale(d[0]); })
                    .y(function(d) { return yscale(d[1]); });

            // reset svg g elements and create new g element for graphs
            svg.selectAll("#positive").remove()
            var positive_graph = svg.append("g")
                .attr('id', 'positive')
                .attr('transform', `translate(200, 20)`)
                .attr('width', width - 800)
                .attr('height', height - 50);

            // Add the X Axis
            var xaxisglyph = positive_graph.append("g")
                            .attr("id", "x-axis-a")
                            .attr("transform", "translate(0, 450)")
            xaxis = d3.axisBottom(xscale)
                        .tickValues(convertedDateRange)
                        .tickFormat(d3.timeFormat("%Y-%m-%d"))
            xaxisglyph.call(xaxis);

            // Add the text label for X Axis
            xaxisglyph.append("text")
                .attr("transform", "translate(400, 32)")
                .attr("id", "x-axis label")
                .attr('stroke', 'black')
                .style("font-size", "12px")
                .style("font-family", "Times")
                .text('Date (YYYY-MM-DD)')

            // Add the Y Axis
            yaxisglyph = positive_graph.append("g")
                            .attr("id", "y-axis-a");
            yaxis = d3.axisLeft()
                        .scale(yscale);
            yaxisglyph.call(yaxis);

            // Add the text label for Y axis
            yaxisglyph.append("text")
                .attr("transform", "translate(-54, 180) rotate(-90)")
                .attr("id", "y-axis label")
                .attr('stroke', 'black')
                .style("font-size", "12px")
                .text('Positive Tweet Counts')

            col_num = 0
            var positive_graph_body = positive_graph.append('g')
                    .attr('id', 'lines-a');
            positive_line_data = processData(line_data, true)

            positive_graph_body.selectAll("lines")
                .data(positive_line_data)
                .enter().append("path")
                .attr("fill", "none")
                .attr("stroke", function(){if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("stroke-width", 1.5)
                .attr("d", function(d){return line(d)});

            col_num = 0
            positive_graph_body.call(tip);
            positive_line_data.forEach(element => {
                positive_graph_body.selectAll("line-circle")
                    .data(element)
                    .enter().append("circle")
                    .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num]} else if (col_num < 17) {return d3.schemeSet2[col_num - 9]} else {return d3.schemeSet3[col_num - 17]}})
                    .attr("r", 5)
                    .attr("cx", function(d){return xscale(d[0]);})
                    .attr("cy", function(d){return yscale(d[1]);})
                    .on("mouseover", tip.show)
                    .on("mouseout", tip.hide);
                col_num+=1
            });

            svg.selectAll("#positive_legend").remove()
            var positive_legend = svg.append("g")
                .attr('id', 'positive_legend')
                .attr('transform', `translate(950, 10)`)
                .attr('width', width - 160)
                .attr('height', height - 50);

            col_num = 0
            positive_legend.selectAll("circle")
                .data(currTeams)
                .enter().append("circle")
                .attr("id", function(d, i) { return d; })
                .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("cx", 20)
                .attr("cy", function(d, i) {return i * 17})
                .attr("r", 6)

            col_num = 0
            positive_legend.selectAll("text")
                .data(currTeams)
                .enter().append("text")
                .attr("id", function(d, i) { return d; })
                .attr("stroke", "black")
                .attr("x", 30)
                .attr("y", function(d, i) {return i * 17 + 3.5})
                .text(function(d, i) { return d.charAt(0).toUpperCase() + d.slice(1);  })
                .style("font-size", "13px")
                .attr("font-weight", "lighter")


            //////////////////////////////// NEGATIVE COUNTS GRAPH \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


            svg.selectAll("#negative").remove()
            var negative_graph = svg.append("g")
                .attr('id', 'negative')
                .attr('transform', `translate(200, 550)`)
                .attr('width', width - 800)
                .attr('height', height - 50);

            // Add the X Axis
            var xaxisglyph_2 = negative_graph.append("g")
                            .attr("id", "x-axis-b")
                            .attr("transform", "translate(0, 450)")
            xaxis_2 = d3.axisBottom(xscale)
                        .tickValues(convertedDateRange)
                        .tickFormat(d3.timeFormat("%Y-%m-%d"))
            xaxisglyph_2.call(xaxis_2);

            // Add the text label for X Axis
            xaxisglyph_2.append("text")
                .attr("transform", "translate(400, 32)")
                .attr("id", "x-axis label 2")
                .attr('stroke', 'black')
                .style("font-size", "12px")
                .style("font-family", "Times")
                .text('Date (YYYY-MM-DD)')

            var yscale = d3.scaleLinear().domain([min_tweet_count_negative, max_tweet_count_negative]).range([450, 0]).nice()
            // Add the Y Axis
            yaxisglyph_2 = negative_graph.append("g")
                            .attr("id", "y-axis-b");
            yaxis_2 = d3.axisLeft()
                        .scale(yscale);
            yaxisglyph_2.call(yaxis_2);

            // Add the text label for Y axis
            yaxisglyph_2.append("text")
                .attr("transform", "translate(-54, 180) rotate(-90)")
                .attr("id", "y-axis label")
                .attr('stroke', 'black')
                .style("font-size", "12px")
                .text('Negative Tweet Counts')

            col_num = 0
            var negative_graph_body = negative_graph.append('g')
                    .attr('id', 'lines-a');
            negative_line_data = processData(line_data, false)

            negative_graph_body.selectAll("lines")
                .data(negative_line_data)
                .enter().append("path")
                .attr("fill", "none")
                .attr("stroke", function(){if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("stroke-width", 1.5)
                .attr("d", function(d){return line(d)})

            negative_graph_body.call(tip)
            col_num = 0
            negative_line_data.forEach(element => {
                negative_graph_body.selectAll("line-circle")
                    .data(element)
                    .enter().append("circle")
                    .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num]} else if (col_num < 17) {return d3.schemeSet2[col_num - 9]} else {return d3.schemeSet3[col_num - 17]}})
                    .attr("r", 5)
                    .attr("cx", function(d){return xscale(d[0]);})
                    .attr("cy", function(d){return yscale(d[1]);})
                    .on("mouseover", tip.show)
                    .on("mouseout", tip.hide);
                col_num+=1
            });

            svg.selectAll("#negative_legend").remove()
            var negative_legend = svg.append("g")
                .attr('id', 'negative_legend')
                .attr('transform', `translate(950, 10)`)
                .attr('width', width - 160)
                .attr('height', height - 50);

            col_num = 0
            negative_legend.selectAll("circle")
                .data(currTeams)
                .enter().append("circle")
                .attr("id", function(d, i) { return d; })
                .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("cx", 20)
                .attr("cy", function(d, i) {return i * 17})
                .attr("r", 6)

            col_num = 0
            negative_legend.selectAll("text")
                .data(currTeams)
                .enter().append("text")
                .attr("id", function(d, i) { return d; })
                .attr("stroke", "black")
                .attr("x", 30)
                .attr("y", function(d, i) {return i * 17 + 3.5})
                .text(function(d, i) { return d.charAt(0).toUpperCase() + d.slice(1); })
                .style("font-size", "13px")
                .attr("font-weight", "lighter")
            
        }
    </script>

</body>

</html>