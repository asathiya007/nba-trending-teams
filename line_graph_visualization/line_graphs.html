<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    <title>Public Opinion of NBA Teams Based on Tweets</title>
    <!-- import required libraries here -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script src= "https://d3js.org/d3-color.v1.min.js"></script> 
    <script src= "https://d3js.org/d3-interpolate.v1.min.js"></script> 
    <script src= "https://d3js.org/d3-scale-chromatic.v1.min.js"></script> 
    <style>
        /* define CSS rules here */
        h1 {text-align: center;}
        /* credit to https://bl.ocks.org/EmbraceLife/739cf167627d7748730eef3663aaec89 for the tooltip css */
        #tooltip {
            position: absolute;
            width: 200px;
            height: auto;
            padding: 10px;
            background-color: white;
            -webkit-border-radius: 10px;
            -moz-border-radius: 10px;
            border-radius: 10px;
            -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
            -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
            box-shadow: 4px 4px 10px rgba(0, 100, 100, 0.4);
            pointer-events: none;
        }
        
        #tooltip.hidden {
            display: none;
        }
        
        #tooltip p {
            margin: 0;
            font-family: sans-serif;
            font-size: 16px;
            line-height: 20px;
        }
    </style>

    <!-- trying to remove some annoying error in chrome console-->
    <link rel="shortcut icon" href="#">

    <title></title>
</head>


<body>
    <h1>Public Opinion of NBA Teams Based on Tweets</h1><hr>

    <div id="line_graph"><svg></svg></div>

    <script>

        // define margin and dimensions for svg
        var margin = 100;
        var width = 1400;
        var height = 1300;

        // create svg and selection menu + menu dropdowns
        var svg = d3.select("svg")
                  .attr('id', 'svg')
                  .attr('width', width)
                  .attr('height', height);

        var selection_menu = svg.append("g")
                  .attr('id', 'menu')
                  .attr('width', width - 160)
                  .attr('height', height - 50);

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 25)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .attr("fill", "black")
                  .text('Model Select')

        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 28)")
                  .attr("width", 175)
                  .attr("height", 50)
                  .append("xhtml:body")
                  .html("<form><select id='modelDropdown'>\
                                <option value='rf'> Random Forest </option>\
                                <option value='nb'> Naive Bayes </option>\
                                <option value='lr'> Logistic Regression </option>\
                                /></form>")

        selection_menu.append("text")
                  .attr("id", "team_select_text")
                  .attr("transform", "translate(0, 75)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .attr("fill", "black")
                  .text('Team Select')
        
        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 80)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select multiple id='teamDropdown'> /></form>")

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 180)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Min Date Select')
        
        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 185)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select id='minDateDropdown'> /></form>")

        selection_menu.append("text")
                  .attr("id", "model_select_text")
                  .attr("transform", "translate(0, 240)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'black')
                  .text('Max Date Select')

        selection_menu.append("foreignObject")
                  .attr("transform", "translate(0, 245)")
                  .attr("width", 100)
                  .attr("height", 100)
                  .append("xhtml:body")
                  .html("<form><select id='maxDateDropdown'> /></form>")

        function processData(global_count_data, positive, currModel, date_range) {
            lines = []
            for (let [key, value] of Object.entries(global_count_data)) {
                currLine = []
                for (let i = 0; i < value[0].length; i++) {
                    if (positive) {
                        if (currModel[0] == "rf") {
                            var sample_tweet = global_rf_pos_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[1][i]), key, ...sample_tweet, value[1][i]])
                        } else if (currModel[0] == "nb") {
                            var sample_tweet = global_nb_pos_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[1][i]), key, ...sample_tweet, value[1][i]])
                        } else {
                            var sample_tweet = global_lr_pos_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[1][i]), key, ...sample_tweet, value[1][i]])
                        }
                    } else {
                        if (currModel[0] == "rf") {
                            var sample_tweet = global_rf_neg_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[2][i]), key, ...sample_tweet, value[2][i]])
                        } else if (currModel[0] == "nb") {
                            var sample_tweet = global_nb_neg_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[2][i]), key, ...sample_tweet, value[2][i]])
                        } else {
                            var sample_tweet = global_lr_neg_tweets.map(function(value,index) { if (value['Team'] == key && value['Date'] == date_range[i]) {return value['Tweet'];}}).filter(function(x) {return x != undefined;})
                            currLine.push([value[0][i], parseInt(value[2][i]), key, ...sample_tweet, value[2][i]])
                        }
                    }
                    
                }
                lines.push(currLine)
            }
            return lines;
        }

        // Purpose: Define tooltip which displays the team name and a sample tweet for each data point
        // For example: when looking at the 2021-11-11 Blazers data point on the positive tweets graph,
        //              we can expect to see the team name and a positive Blazers Tweet 
        //              from that day displayed on the tooltip.
        var tip = d3.tip().attr("id", "tooltip").attr('class', 'd3-tip')
                    .html(function(d) {return "<b>Team:</b> " + d[2].charAt(0).toUpperCase() + d[2].slice(1) +
                                              "<br><b>Tweet Count:</b> " + d[4] +
                                              "<br><b>Sample Tweet:</b> " + d[3] ;})

        // global variables 
        var global_count_data = null
        var currModel = ["rf"]
        var currTeams = ['76ers', 'blazers', 'bucks', 'bulls', 'cavaliers', 'celtics', 'grizzlies', 'hawks', 'heat', 'hornets', 'jazz', 'kings', 'knicks', 'lakers', 'magic', 'mavericks', 'nets', 'nuggets', 'pacers', 'pelicans', 'pistons', 'raptors', 'rockets', 'spurs', 'suns', 'thunder', 'timberwolves', 'wizards']
        var minDate = "2021-11-09"
        var maxDate = null
        var absoluteMaxDate = null
        var min_positive_tweet_count = 0
        var max_positive_tweet_count = 0
        var min_negative_tweet_count = 0
        var max_negative_tweet_count = 0
        var global_rf_pos_tweets = null
        var global_rf_neg_tweets = null
        var global_nb_pos_tweets = null
        var global_nb_neg_tweets = null
        var global_lr_pos_tweets = null
        var global_lr_neg_tweets = null
        Promise.all([
            // enter code to read files
            d3.csv("data_files/tweet_counts.csv"),
            d3.csv("data_files/rf_positive_tweets.csv"),
            d3.csv("data_files/rf_negative_tweets.csv"),
            d3.csv("data_files/nb_positive_tweets.csv"),
            d3.csv("data_files/nb_negative_tweets.csv"),
            d3.csv("data_files/lr_positive_tweets.csv"),
            d3.csv("data_files/lr_negative_tweets.csv")
        ]).then(
            // enter code to call ready() with required arguments
            results => {
                global_count_data = results[0];
                global_rf_pos_tweets = results[1];
                global_rf_neg_tweets = results[2];
                global_nb_pos_tweets = results[3];
                global_nb_neg_tweets = results[4];
                global_lr_pos_tweets = results[5];
                global_lr_neg_tweets = results[6];
                ready();
            }
        );
        
        // Purpose: called once the data from files have been read, initiates the 
        function ready() {

            d3.select("#teamDropdown").selectAll("option")
              .data(['76ers', 'Blazers', 'Bucks', 'Bulls', 'Cavaliers', 'Celtics', 'Grizzlies', 'Hawks', 'Heat', 'Hornets', 'Jazz', 'Kings', 'Knicks', 'Lakers', 'Magic', 'Mavericks', 'Nets', 'Nuggets', 'Pacers', 'Pelicans', 'Pistons', 'Raptors', 'Rockets', 'Spurs', 'Suns', 'Thunder', 'Timberwolves', 'Wizards'])
              .enter()
              .append("option")
              .text(function(d){return d;})

            var checkboxes = document.querySelectorAll("input[type=checkbox][name=teamselect]");
            var selectedTeams = []
            checkboxes.forEach(function(checkbox) {
                checkbox.addEventListener('change', function() {
                    selectedTeams = 
                    Array.from(checkboxes) // Convert checkboxes to an array to use filter and map.
                    .filter(i => i.checked) // Use Array.filter to remove unchecked checkboxes.
                    .map(i => i.value) // Use Array.map to extract only the checkbox values from the array of objects.
                })
            });
            
            var dateParser = d3.timeParse("%Y-%m-%d")
            stringDates = [... new Set(global_count_data.map(function(value,index) { return value['Date']; }))]
            var convertedDates = stringDates.map(function(x, index) {return dateParser(x).getTime()})
            minDate = stringDates[convertedDates.indexOf(Math.min(...convertedDates))]
            maxDate = stringDates[convertedDates.indexOf(Math.max(...convertedDates))]
            absoluteMaxDate = stringDates[convertedDates.indexOf(Math.max(...convertedDates))]
            
            // for positive tweets
            min_rftweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['RF Positive']})))
            max_rftweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['RF Positive']})))

            min_nbtweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['NB Positive']})))
            max_nbtweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['NB Positive']})))

            min_lrtweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['LR Positive']})))
            max_lrtweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['LR Positive']})))

            min_positive_tweet_count = Math.min(min_rftweet_count, min_nbtweet_count, min_lrtweet_count)
            max_positive_tweet_count = Math.max(max_rftweet_count, max_nbtweet_count, max_lrtweet_count)

            // for negative tweets
            min_rftweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['RF Negative']})))
            max_rftweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['RF Negative']})))

            min_nbtweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['NB Negative']})))
            max_nbtweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['NB Negative']})))

            min_lrtweet_count = Math.min(... new Set(global_count_data.map(function(value,index) { return value['LR Negative']})))
            max_lrtweet_count = Math.max(... new Set(global_count_data.map(function(value,index) { return value['LR Negative']})))

            min_negative_tweet_count = Math.min(min_rftweet_count, min_nbtweet_count, min_lrtweet_count)
            max_negative_tweet_count = Math.max(max_rftweet_count, max_nbtweet_count, max_lrtweet_count)

            // event listener for the dropdown. Update choropleth and legend when selection changes. Call createMapAndLegend() with required arguments.
            var select_Model = document.getElementById("modelDropdown")
            select_Model.addEventListener("change", function(){ var models = []; selected = d3.select(this).selectAll("option:checked").each(function() { models.push(this.value) }); currModel = models; createMapAndLegend(currModel, currTeams, minDate, maxDate); });

            var select_Teams = document.getElementById("teamDropdown")
            select_Teams.addEventListener("change", function(){ var teams = []; selected = d3.select(this).selectAll("option:checked").each(function() { teams.push(this.value.toLowerCase()) }); currTeams = teams; createMapAndLegend(currModel, currTeams, minDate, maxDate); });

            var select_Min_Date = document.getElementById("minDateDropdown")
            select_Min_Date.addEventListener("change", function(){ var values = []; selected = d3.select(this).selectAll("option:checked").each(function() { values.push(this.value) }); minDate = values[0]; createMapAndLegend(currModel, currTeams, minDate, maxDate); });

            var select_Max_Date = document.getElementById("maxDateDropdown")
            select_Max_Date.addEventListener("change", function(){ var values = []; selected = d3.select(this).selectAll("option:checked").each(function() { values.push(this.value) }); maxDate = values[0]; createMapAndLegend(currModel, currTeams, minDate, maxDate); });
            // create Choropleth with default option. Call createMapAndLegend() with required arguments. 
            createMapAndLegend(currModel, currTeams, minDate, maxDate);
        }

        // this function should create a Choropleth and legend using the world and global_count_data arguments for a selectedGame
        // also use this function to update Choropleth and legend when a different game is selected from the dropdown
        function createMapAndLegend(currModel, currTeams, minDate, maxDate){ 
            svg.selectAll("#error_date_range").remove()
            dates = [... new Set(global_count_data.map(function(value,index) { return value['Date']; }))]
            var dateParser = d3.timeParse("%Y-%m-%d")
            var minConvertedDate = dateParser(minDate).getTime()
            var maxConvertedDate = dateParser(maxDate).getTime()
            if (minConvertedDate >= maxConvertedDate)
            {
                selection_menu.append("text")
                  .attr("id", "error_date_range")
                  .attr("transform", "translate(0, 530)")
                  .attr("width", 100)
                  .attr("height", 150)
                  .attr('stroke', 'red')
                  .text('Error: invalid date selection. Min date must be less than max date. Code has defaulted to the maximum possible date.')
                
                maxDate = absoluteMaxDate
                maxConvertedDate = dateParser(maxDate).getTime()
            }

            stringDates = [... new Set(global_count_data.map(function(value,index) { if (maxConvertedDate > dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            d3.select("#minDateDropdown").selectAll("option")
              .data(stringDates)
              .enter()
              .append("option")
              .text(function(d){return d;})

            stringDatesWithinBounds = [... new Set(global_count_data.map(function(value,index) { if (minConvertedDate < dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            d3.select("#maxDateDropdown").selectAll("option")
              .data(stringDatesWithinBounds)
              .enter()
              .append("option")
              .text(function(d){return d;})
              .property("selected", function(d) {return d === maxDate})

            var date_range = [... new Set(global_count_data.map(function(value,index) { if (minConvertedDate <= dateParser(value['Date']).getTime() && maxConvertedDate >= dateParser(value['Date']).getTime()) {return value['Date']} }).filter(function(x) {return x != undefined;} ))]
            var convertedDateRange = date_range.map(function(x, index) {return dateParser(x).getTime()})
            date_scale_min = convertedDateRange[convertedDateRange.indexOf(Math.min(...convertedDateRange))]
            date_scale_max = convertedDateRange[convertedDateRange.indexOf(Math.max(...convertedDateRange))]

            line_data = {}

            // for each team
            currTeams.forEach(element => {
                positiveCounts = []
                negativeCounts = []
                if (currModel == "rf") //random forest
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['RF Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['RF Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                    
                }
                else if (currModel == "nb") //naive bayes
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['NB Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['NB Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                }
                else //logistic regression
                {
                    date_range.forEach(day => {
                        positiveCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['LR Positive']; }}).filter(function(x) {return x != undefined;} ))
                        negativeCounts.push(...global_count_data.map(function(value,index) { if (value['Team'] == element && value['Date'] == day){return value['LR Negative']; }}).filter(function(x) {return x != undefined;} ))
                    });
                }
                line_data[element] = [convertedDateRange, positiveCounts, negativeCounts]
            });


            // create scales x & y for X and Y axis and set their ranges
            var xscale = d3.scaleLinear().domain([date_scale_min, date_scale_max]).range([0, width - 350])
            var yscale = d3.scaleLinear().domain([min_positive_tweet_count, max_positive_tweet_count]).range([450, 0]).nice()

            const line = d3.line()
                    .x(function(d) { return xscale(d[0]); })
                    .y(function(d) { return yscale(d[1]); });

            // reset svg g elements and create new g element for graphs
            svg.selectAll("#positive").remove()
            var positive_graph = svg.append("g")
                .attr('id', 'positive')
                .attr('transform', `translate(200, 20)`)
                .attr('width', width - 800)
                .attr('height', height - 50);

            // Add line graph title
            positive_graph.append("text")
                .attr("transform", "translate(360, 0)")
                .attr("id", "title-a")
                .style("font-size", "18px")
                .text('Date vs. Positive Tweet Counts Per NBA Team')

            // Add the X Axis
            var xaxisglyph = positive_graph.append("g")
                            .attr("id", "x-axis-a")
                            .attr("transform", "translate(0, 450)")
            xaxis = d3.axisBottom(xscale)
                        .tickValues(convertedDateRange)
                        .tickFormat(d3.timeFormat("%Y-%m-%d"))
            xaxisglyph.call(xaxis);
            xaxisglyph.selectAll("text")
                .attr("transform", "translate(0, 5) rotate(20)")

            // Add the text label for X Axis
            positive_graph.append("text")
                .attr("transform", "translate(490, 500)")
                .attr("id", "x-axis label")
                .attr('stroke', 'black')
                .attr("fill", "black")
                .style("font-size", "14px")
                .style("font-family", "Times")
                .text('Date (YYYY-MM-DD)')

            // Add the Y Axis
            yaxisglyph = positive_graph.append("g")
                            .attr("id", "y-axis-a");
            yaxis = d3.axisLeft()
                        .scale(yscale);
            yaxisglyph.call(yaxis);

            // Add the text label for Y axis
            yaxisglyph.append("text")
                .attr("transform", "translate(-35, 150) rotate(-90)")
                .attr("id", "y-axis label")
                .attr('stroke', 'black')
                .attr("fill", "black")
                .style("font-size", "14px")
                .text('Positive Tweet Counts')
                // .attr("font-weight", "bold")

            col_num = 0
            var positive_graph_body = positive_graph.append('g')
                    .attr('id', 'lines-a');
            positive_line_data = processData(line_data, true, currModel, date_range)

            positive_graph_body.selectAll("lines")
                .data(positive_line_data)
                .enter().append("path")
                .attr("fill", "none")
                .attr("stroke", function(){if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("stroke-width", 1.5)
                .attr("d", function(d){return line(d)});

            col_num = 0
            positive_graph_body.call(tip);
            positive_line_data.forEach(element => {
                positive_graph_body.selectAll("line-circle")
                    .data(element)
                    .enter().append("circle")
                    .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num]} else if (col_num < 17) {return d3.schemeSet2[col_num - 9]} else {return d3.schemeSet3[col_num - 17]}})
                    .attr("r", 5)
                    .attr("cx", function(d){return xscale(d[0]);})
                    .attr("cy", function(d){return yscale(d[1]);})
                    .on("mouseover", tip.show)
                    .on("mouseout", tip.hide);
                col_num+=1
            });

            svg.selectAll("#positive_legend").remove()
            var positive_legend = svg.append("g")
                .attr('id', 'positive_legend')
                .attr('transform', `translate(1270, 10)`)
                .attr('width', width - 160)
                .attr('height', height - 50);

            col_num = 0
            positive_legend.selectAll("circle")
                .data(currTeams)
                .enter().append("circle")
                .attr("id", function(d, i) { return d; })
                .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("cx", 20)
                .attr("cy", function(d, i) {return i * 17})
                .attr("r", 6)

            col_num = 0
            positive_legend.selectAll("text")
                .data(currTeams)
                .enter().append("text")
                .attr("id", function(d, i) { return d; })
                .attr("fill", "black")
                .attr("x", 30)
                .attr("y", function(d, i) {return i * 17 + 3.5})
                .text(function(d, i) { return d.charAt(0).toUpperCase() + d.slice(1);  })
                .style("font-size", "13px")
                .attr("font-weight", "lighter")


            //////////////////////////////// NEGATIVE COUNTS GRAPH \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
            svg.selectAll("#negative").remove()
            var negative_graph = svg.append("g")
                .attr('id', 'negative')
                .attr('transform', `translate(200, 550)`)
                .attr('width', width - 800)
                .attr('height', height - 50);

            // Add line graph title
            negative_graph.append("text")
                .attr("transform", "translate(360, 0)")
                .attr("id", "title-a")
                .style("font-size", "18px")
                .text('Date vs. Negative Tweet Counts Per NBA Team')

            // Add the X Axis
            var xaxisglyph_2 = negative_graph.append("g")
                            .attr("id", "x-axis-b")
                            .attr("transform", "translate(0, 450)")
            xaxis_2 = d3.axisBottom(xscale)
                        .tickValues(convertedDateRange)
                        .tickFormat(d3.timeFormat("%Y-%m-%d"))
            xaxisglyph_2.call(xaxis_2);
            xaxisglyph_2.selectAll("text")
                .attr("transform", "translate(0, 5) rotate(20)")

            // Add the text label for X Axis
            negative_graph.append("text")
                .attr("transform", "translate(490, 500)")
                .attr("id", "x-axis label 2")
                .attr('stroke', 'black')
                .attr("fill", "black")
                .style("font-size", "14px")
                .style("font-family", "Times")
                .text('Date (YYYY-MM-DD)')

            var yscale = d3.scaleLinear().domain([min_negative_tweet_count, max_negative_tweet_count]).range([450, 0]).nice()
            // Add the Y Axis
            yaxisglyph_2 = negative_graph.append("g")
                            .attr("id", "y-axis-b");
            yaxis_2 = d3.axisLeft()
                        .scale(yscale);
            yaxisglyph_2.call(yaxis_2);

            // Add the text label for Y axis
            yaxisglyph_2.append("text")
                .attr("transform", "translate(-45, 150) rotate(-90)")
                .attr("id", "y-axis label")
                .attr('stroke', 'black')
                .attr("fill", "black")
                .style("font-size", "14px")
                .text('Negative Tweet Counts')

            col_num = 0
            var negative_graph_body = negative_graph.append('g')
                    .attr('id', 'lines-a');
            negative_line_data = processData(line_data, false, currModel, date_range)

            negative_graph_body.selectAll("lines")
                .data(negative_line_data)
                .enter().append("path")
                .attr("fill", "none")
                .attr("stroke", function(){if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("stroke-width", 1.5)
                .attr("d", function(d){return line(d)})

            negative_graph_body.call(tip)
            col_num = 0
            negative_line_data.forEach(element => {
                negative_graph_body.selectAll("line-circle")
                    .data(element)
                    .enter().append("circle")
                    .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num]} else if (col_num < 17) {return d3.schemeSet2[col_num - 9]} else {return d3.schemeSet3[col_num - 17]}})
                    .attr("r", 5)
                    .attr("cx", function(d){return xscale(d[0]);})
                    .attr("cy", function(d){return yscale(d[1]);})
                    .on("mouseover", tip.show)
                    .on("mouseout", tip.hide);
                col_num+=1
            });

            svg.selectAll("#negative_legend").remove()
            var negative_legend = svg.append("g")
                .attr('id', 'negative_legend')
                .attr('transform', `translate(1270, 540)`)
                .attr('width', width - 160)
                .attr('height', height - 50);

            col_num = 0
            negative_legend.selectAll("circle")
                .data(currTeams)
                .enter().append("circle")
                .attr("id", function(d, i) { return d; })
                .attr("fill", function(d, i) {if (col_num < 9){return d3.schemeSet1[col_num++]} else if (col_num < 17) {return d3.schemeSet2[col_num++ - 9]} else {return d3.schemeSet3[col_num++ - 17]}})
                .attr("cx", 20)
                .attr("cy", function(d, i) {return i * 17})
                .attr("r", 6)

            col_num = 0
            negative_legend.selectAll("text")
                .data(currTeams)
                .enter().append("text")
                .attr("id", function(d, i) { return d; })
                .attr("fill", "black")
                .attr("x", 30)
                .attr("y", function(d, i) {return i * 17 + 3.5})
                .text(function(d, i) { return d.charAt(0).toUpperCase() + d.slice(1); })
                .style("font-size", "13px")
                .attr("font-weight", "lighter")
            
        }
    </script>

</body>

</html>